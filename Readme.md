# Design Pattern

https://refactoring.guru/design-patterns

***

## [목차]
[Creational patterns](#Creational-patterns) <br/>
 - [Factory Method](#Factory-Method)
 - [Abstract Factory](#Abstract-Factory)
  
  <br/>
  
[Structural patterns](#Structural-patterns) <br/> 
   
 - [Adapter](#Adapter)
 - [Decorator](#Decorator)
 - [Composite](#Composite)
 
  <br/>
  
[Behavioral patterns](#Behavioral-patterns)

- [Strategy](#Strategy)
- [State](#State)

***

## Creational patterns

### Factory Method 

객체를 생성하기 위해 인터페이스를 정의하고 서브클래스에서 어떤 인스턴스를 생성할지 결정하는 방법

`new` operator 를 통해 객체를 생성하지 않는다. 객체 생성에 다형성을 부여하고 싶은 경우에 Factory Method 를 쓰면 된다. 

뭐 예를들면 운송수단(Transport)을 통해서 배송을 하는데 `ship` 을 통해서 해야하는지 `truck` 을 통해서 해야하는지 결정 지어줘야할 때. 

Applicability 

- 사전에 만들어야 할 객체의 정확한 타입이나 의존성을 알기 어려운 경우에 팩토리 메소드를 통해서 이후에 서브 클래스를 통해 생성을 하도록 만들 수 있다. 

  - 팩토리 메소드 패턴을 적용하면 객체 생성 코드를 분리시킬 수 있어서 확장시키기 쉽다. 즉 미래에 추가되는 타입이 있는 경우에 확장 시키기 쉽다.   
   
-  라이브러리나 프레임워크를 사용자에게 제공하고 사용자가 이를 확장해서 사용할 수 있도록 할려면 팩토리 메소드 패턴을 사용하라. 

  - 추상 팩토리 클래스를 상속하고 팩토리 메소드를 오버라이딩 해서 이를 해결해줄 수 있다. 사용자가 정의한 팩토리 클래스를 정의하고 그 팩토리 클래스를 표준으로 사용하도록 하고 (프레임워크 단에서 Single Factory Method 으로 해놓는 방법이 있다.) 
    
    타입에 맞는 객체를 반환해주기만 하면 된다.   
    
- 매번 기존 객체를 다시 빌드하지 않고 객체를 재사용해서 리소스를 절약하고 싶다면 팩토리 메소드 패턴을 사용해라 

  - 리소스에 민감한 객체를 다루는 경우 (데이버테이스 커넥션, 네트워크 리소스 등) 미리 여러개 만들어놓고 재사용하는게 이점이 많다. 

***

### Abstract Factory

추상 팩토리 패턴은 구체적인 클래스를 지정하지 않고 객체의 집합을 생성할 수 있는 디자인 패턴이다.  

***

## Structural patterns

### Adapter 

어댑터 패턴은 호환되지 않는 인터페이스를 가진 두 객체가 서로 협력할 수 있도록 하는 패턴이다. 

뭐 예를들면 주식 앱에서 데이터를 XML 형식으로 다운받았지만 데이터 분석 라이브러리는 JSON 형식이 필요한 경우다. 이런 경우에 어댑터 페턴을 사용할 수 있다.

Applicability 

- 기존의 존재하는 클래스를 이용하지만 호환가능하지 않을때 어댑터 패턴을 사용하라. 

  - 이런 방식의 사용은 중간 계층의 레이어를 통해 변환해주는 역할을 어댑터가 한다고 생각하면 된다.
  
- 기존의 기능이 부족한 서브 클래스를 재사용 하고싶고 공통적인 기능을 슈퍼 클래스에 넣기 힘들때 어댑터 패턴을 사용하면 해결할 수 있다.

  - 슈퍼 클래스에 기능을 넣기 어렵고 서브 클래스에 기능을 추가해 확장해서 사용하기에는 코드가 중복되고 지저분한 경우에 이런 어댑터 패턴을 사용한다. 
  
  - 어댑터 패턴을 이용해 객체를 감싸고 공통 인터페이스를 통해 공통된 기능을 추가한다. 이런 패턴은 런타임 시점에 동적으로 결정이 가능하며 데코레이터 패턴과 유사하디.   

***

### Decorator

데코레이터 패턴은 객체를 감싼 새로운 객체를 통해서 기존 객체의 새로운 동작을 부여하는 방식이다.

이를 통해 객체는 동적으로 새로운 책임을 추가할 수 있다. 기능을 추가하는 면에서 서브 클래스를 생성하는 것보다 더 융통성이 있다.

가끔 전체 클래스에 새로운 기능을 추가할 필요는 없지만 기존의 몇 클래스에는 새로운 책임을 부여할 필요가 있다. 

뭐 예를들면 GUI 툴킷에서 모든 사용자 인터페이스에서는 스크롤링이 필요하지 않지만 몇몇에는 필요하던가. 

이렇게 기존의 기능에 새로운 기능이 필요한 경우에는 상속을 이용하는게 일반적이다. 상속을 통해서 새로운 속성을 부여받는게 일반적이지만 

이런 상속 클래스를 미리 만들어놔야 한다는 정적인 특성이 한계가 있다. 데코레이터 패턴을 이용하면 다른 객체를 계속 중첩해서 둘러싸는게 가능하기 떄문에 

동적으로 이를 제어하는게 가능하고 추상화를 해서 제공하는 겐 가능하다. 

Applicability

- 런타임에 객체를 추가 동작을 할당하는 경우 데코레이터 패턴이 적합하다. 

  - 런타임에 로직의 다양한 조합을 사용해서 개체를 구성하는게 가능하다. 이는 다 공통된 인터페이스를 가지고 있으니까 동일한 방식으로 처리할 수 있다.
  
- 상속을 이용해서 객체의 동작을 상속하는게 어렵거나 어색한 경우에 적합하다. 
  
  - 많은 프로그래밍 언어에서는 추가 상속을 막도록 하는 final 키워드가 존재할 수도 있다. 
 
***

### Composite

컴포지트 패턴은 트리 구조로 작성된 복합 객체를 단일 객체로 취급할 수 있는 것을 목적으로 한다. 

뭐 예를 들면 박스안에 Product 가 여러개 있을 수 있고 박스안에 박스가 있을 수 있다.   

컴포지트 패턴을 사용하는 클라이언트느 복합 객체인지 단일 객체인지 구별하지 않고 동일한 인터페이스를 통해서 사용하는 것이 가능하다. 

Applicability 

- 너가 구현하는 객체 구조가 트리와 같다면 컴포지트 패턴을 사용해라 

  - 컴포지트 패턴은 동일한 인터페이스를 제공해줘서 하나의 싱글 객체에서 수행할 수 있고 복합 객체에서도 동일한 메소드로 여러개의 싱글 객체들을 실행할 수 있다. 
  
  - 복합 객체는 또 다른 복합 객체를 가지고 있을 수도 있고 싱글 객체를 가지고 있을 수 있다. (트리 구조와 유사하다.)
  
- 하나의 객체를 실행하던 복합 객체를 실행하던 일관성 있게 처리하도록 하고 싶다면 컴포지트 패턴을 사용하라. 

  - 계속 말하지만 컴포지트 패턴은 복합 객체던 싱글 객체던 동일한 인터페이스를 사용한다. 그러므로 실행하는데 걱정하지 않아도 된다.   



***

## Behavioral patterns

### Strategy

하나의 결과를 만드는 목적(메소드)는 동일하나 그 목적을 달성할 수 있는 전략이 다양한 경우에 사용되는 패턴으로 동적으로 알고리즘을 교체할 수 있다. 

Applicability 
  
- 전략 패턴은 하나의 오브젝트에서 다양한 알고리즘을 사용해서 문제를 해결할 수 있고 이를 런타임 시점에 결정할 수 있기를 바란다면 사용하는게 좋다. 
  
- 클래스가 유사한 것이 많고 행동하는 방식이 조금씩 다르다면 전략 패턴을 사용하는 것이 좋다. 
  
- 이 전략 패턴을 사용함으로써 비즈니스 로직에서 구현의 디테일을 숨길 수 있다. 
  
- 만약 하나의  클래스에서 조건에 따라 동일한 알고리즘을 조금씩 변형해서 사용한다면 이 패턴을 사용하는 것이 좋다. 

***

### State 

객체는 다양한 상태를 객체화하여 객체가 상태에 따라 다른 행동을 할 수 있도록 하는게 가능하다. 

대상은 상태 객체를 참조하는게 가능하고 어떤 조건에 따라 상태를 바꾸는게 가능하고 그에따라 행동 양상이 바뀔 수 있다. 

상태 패턴을 이용하면 상태를 가지고 있는 객체를 상태 조건에 따라 분기해서 실행하지 않아도 되고 그냥 상태를 직접 사용하면 된다. 


Applicability

- 현재 객체가 상태에 따라 다르게 동작해야 하고 상태 수가 많고 상태가 자주 변경될 가능성이 있다면 상태 패턴을 사용해라.

- 클래스가 필드 값 조건에 따라 다르게 행동하고 있도록 설계되었다면 이 패턴을 통해서 개선할 수 있다. 

- 상태 기반으로 검사하는 조건문이 중복되는 경우가 많다면 이 패턴을 사용할 수 있다. 




